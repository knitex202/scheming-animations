import type { SetTypeSubArg, SecondaryIndexIrShape } from '@aws-amplify/data-schema-types';
import { Brand } from './util';
import { ModelField, InternalField } from './ModelField';
import type { ModelRelationalField, InternalRelationalField, ModelRelationalFieldParamShape } from './ModelRelationalField';
import { AllowModifier, Authorization } from './Authorization';
import { RefType } from './RefType';
import { EnumType, EnumTypeParamShape } from './EnumType';
import { CustomType, CustomTypeParamShape } from './CustomType';
import { ModelIndexType, InternalModelIndexType } from './ModelIndex';
import { SecondaryIndexToIR } from './MappedTypes/MapSecondaryIndexes';
declare const brandName = "modelType";
type ModelFields = Record<string, ModelField<any, any, any> | ModelRelationalField<any, string, any, any> | RefType<any, any, any> | EnumType<EnumTypeParamShape> | CustomType<CustomTypeParamShape>>;
type InternalModelFields = Record<string, InternalField | InternalRelationalField>;
type ModelData = {
    fields: ModelFields;
    identifier: string[];
    secondaryIndexes: ReadonlyArray<ModelIndexType<any, any, any, any, any>>;
    authorization: Authorization<any, any, any>[];
};
type InternalModelData = ModelData & {
    fields: InternalModelFields;
    identifier: string[];
    secondaryIndexes: ReadonlyArray<InternalModelIndexType>;
    authorization: Authorization<any, any, any>[];
};
export type ModelTypeParamShape = {
    fields: ModelFields;
    identifier: string[];
    secondaryIndexes: ReadonlyArray<SecondaryIndexIrShape>;
    authorization: Authorization<any, any, any>[];
};
type SecondaryIndexFields<T extends Record<string, unknown>> = keyof {
    [Field in keyof T as NonNullable<T[Field]> extends string | number ? Field : never]: T[Field];
} & string;
type ExtractType<T extends ModelTypeParamShape> = {
    [FieldProp in keyof T['fields'] as T['fields'][FieldProp] extends ModelField<any, any, any> ? FieldProp : never]: T['fields'][FieldProp] extends ModelField<infer R, any, any> ? R : never;
};
type GetRequiredFields<T> = {
    [FieldProp in keyof T as T[FieldProp] extends NonNullable<T[FieldProp]> ? FieldProp : never]: T[FieldProp];
};
type IdentifierMap<T extends ModelTypeParamShape> = GetRequiredFields<ExtractType<T>>;
type IdentifierFields<T extends ModelTypeParamShape> = keyof IdentifierMap<T> & string;
type IdentifierType<T extends ModelTypeParamShape, Fields extends string = IdentifierFields<T>> = Array<Fields>;
export type AddRelationshipFieldsToModelTypeFields<Model, RelationshipFields extends Record<string, ModelRelationalField<ModelRelationalFieldParamShape, string, any, any>>> = Model extends ModelType<infer ModelParam extends ModelTypeParamShape, infer HiddenKeys> ? ModelType<SetTypeSubArg<ModelParam, 'fields', ModelParam['fields'] & RelationshipFields>, HiddenKeys> : never;
export type ModelType<T extends ModelTypeParamShape, K extends keyof ModelType<T> = never> = Omit<{
    identifier<ID extends IdentifierType<T> = []>(identifier: ID): ModelType<SetTypeSubArg<T, 'identifier', ID>, K | 'identifier'>;
    secondaryIndexes<const SecondaryIndexPKPool extends string = SecondaryIndexFields<ExtractType<T>>, const Indexes extends readonly ModelIndexType<string, string, unknown, readonly [], any>[] = readonly [], const IndexesIR extends readonly any[] = SecondaryIndexToIR<Indexes, ExtractType<T>>>(callback: (index: <PK extends SecondaryIndexPKPool>(pk: PK) => ModelIndexType<SecondaryIndexPKPool, PK, ReadonlyArray<Exclude<SecondaryIndexPKPool, PK>>>) => Indexes): ModelType<SetTypeSubArg<T, 'secondaryIndexes', IndexesIR>, K | 'secondaryIndexes'>;
    authorization<AuthRuleType extends Authorization<any, any, any>>(callback: (allow: Omit<AllowModifier, 'resource'>) => AuthRuleType | AuthRuleType[]): ModelType<SetTypeSubArg<T, 'authorization', AuthRuleType[]>, K | 'authorization'>;
}, K> & Brand<typeof brandName>;
/**
 * External representation of Model Type that exposes the `addRelationships` modifier.
 * Used on the complete schema object.
 */
export type SchemaModelType<T extends ModelType<ModelTypeParamShape, never | 'identifier'> = ModelType<ModelTypeParamShape, never | 'identifier'>, ModelName extends string = string, IsRDS extends boolean = false> = IsRDS extends true ? T & {
    addRelationships<Param extends Record<string, ModelRelationalField<any, string, any, any>> = Record<never, never>>(relationships: Param): Record<ModelName, Param>;
    fields: T extends ModelType<infer R extends ModelTypeParamShape, any> ? R['fields'] : never;
} : T;
/**
 * Internal representation of Model Type that exposes the `data` property.
 * Used at buildtime.
 */
export type InternalModel = SchemaModelType<ModelType<ModelTypeParamShape>, string, true> & {
    data: InternalModelData;
};
/**
 * Model Type type guard
 * @param modelType - api-next ModelType
 * @returns true if the given value is a ModelSchema
 */
export declare const isSchemaModelType: (modelType: any | SchemaModelType) => modelType is ModelType<ModelTypeParamShape, "identifier">;
/**
 * A data model that creates a matching Amazon DynamoDB table and provides create, read (list and get), update,
 * delete, and subscription APIs.
 *
 * @param fields database table fields. Supports scalar types and relationship types.
 * @returns a data model definition
 */
export declare function model<T extends ModelFields>(fields: T): ModelType<{
    fields: T;
    identifier: Array<'id'>;
    secondaryIndexes: [];
    authorization: [];
}>;
export {};
