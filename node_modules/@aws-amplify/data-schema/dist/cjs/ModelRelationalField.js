'use strict';

Object.defineProperty(exports, "__esModule", { value: true });
exports.belongsTo = exports.hasMany = exports.hasOne = exports.ModelRelationshipTypes = exports.__auth = void 0;
const Authorization_1 = require("./Authorization");
/**
 * Used to "attach" auth types to ModelField without exposing them on the builder.
 */
exports.__auth = Symbol('__auth');
var ModelRelationshipTypes;
(function (ModelRelationshipTypes) {
    ModelRelationshipTypes["hasOne"] = "hasOne";
    ModelRelationshipTypes["hasMany"] = "hasMany";
    ModelRelationshipTypes["belongsTo"] = "belongsTo";
})(ModelRelationshipTypes || (exports.ModelRelationshipTypes = ModelRelationshipTypes = {}));
const relationModifierMap = {
    belongsTo: ['authorization'],
    hasMany: ['arrayRequired', 'valueRequired', 'authorization'],
    hasOne: ['required', 'authorization'],
};
function _modelRelationalField(type, relatedModel, references) {
    const data = {
        relatedModel,
        type,
        fieldType: 'model',
        array: false,
        valueRequired: false,
        arrayRequired: false,
        references,
        authorization: [],
    };
    data.array = type === 'hasMany';
    const relationshipBuilderFunctions = {
        required() {
            data.arrayRequired = true;
            return this;
        },
        arrayRequired() {
            data.arrayRequired = true;
            return this;
        },
        valueRequired() {
            data.valueRequired = true;
            return this;
        },
        authorization(callback) {
            const rules = callback(Authorization_1.allow);
            data.authorization = Array.isArray(rules) ? rules : [rules];
            return this;
        },
    };
    const builder = Object.fromEntries(relationModifierMap[type].map((key) => [
        key,
        relationshipBuilderFunctions[key],
    ]));
    return {
        ...builder,
        data,
    };
}
/**
 * Create a one-directional one-to-one relationship between two models using the `hasOne("MODEL_NAME")` method.
 * A hasOne relationship always uses a reference to the related model's identifier. Typically this is the `id` field
 * unless overwritten with the `identifier()` method.
 * @param relatedModel the name of the related model
 * @returns a one-to-one relationship definition
 */
function hasOne(relatedModel, references) {
    return _modelRelationalField(ModelRelationshipTypes.hasOne, relatedModel, Array.isArray(references) ? references : [references]);
}
exports.hasOne = hasOne;
/**
 * Create a one-directional one-to-many relationship between two models using the `hasMany()` method.
 * @param relatedModel the name of the related model
 * @returns a one-to-many relationship definition
 */
function hasMany(relatedModel, references) {
    return _modelRelationalField(ModelRelationshipTypes.hasMany, relatedModel, Array.isArray(references) ? references : [references]);
}
exports.hasMany = hasMany;
/**
 * Make a `hasOne()` or `hasMany()` relationship bi-directional using the `belongsTo()` method.
 * The belongsTo() method requires that a hasOne() or hasMany() relationship already exists from
 * parent to the related model.
 * @param relatedModel name of the related `.hasOne()` or `.hasMany()` model
 * @returns a belong-to relationship definition
 */
function belongsTo(relatedModel, references) {
    return _modelRelationalField(ModelRelationshipTypes.belongsTo, relatedModel, Array.isArray(references) ? references : [references]);
}
exports.belongsTo = belongsTo;
//# sourceMappingURL=ModelRelationalField.js.map
