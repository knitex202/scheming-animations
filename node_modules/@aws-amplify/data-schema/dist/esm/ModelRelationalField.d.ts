import { SetTypeSubArg } from '@aws-amplify/data-schema-types';
import { Brand } from './util';
import { AllowModifier, Authorization } from './Authorization';
/**
 * Used to "attach" auth types to ModelField without exposing them on the builder.
 */
export declare const __auth: unique symbol;
declare const brandName = "modelRelationalField";
export declare enum ModelRelationshipTypes {
    hasOne = "hasOne",
    hasMany = "hasMany",
    belongsTo = "belongsTo"
}
type RelationshipTypes = `${ModelRelationshipTypes}`;
type ModelRelationalFieldData = {
    fieldType: 'model';
    type: ModelRelationshipTypes;
    relatedModel: string;
    array: boolean;
    valueRequired: boolean;
    arrayRequired: boolean;
    references: string[];
    authorization: Authorization<any, any, any>[];
};
export type ModelRelationalFieldParamShape = {
    type: 'model';
    relationshipType: string;
    relatedModel: string;
    array: boolean;
    valueRequired: boolean;
    references: string[];
    arrayRequired: boolean;
};
type ModelRelationalFieldFunctions<T extends ModelRelationalFieldParamShape, RM extends string | symbol, K extends keyof ModelRelationalField<T, RM> = never> = {
    /**
     * When set, it requires the value of the relationship type to be required.
     */
    valueRequired(): ModelRelationalField<SetTypeSubArg<T, 'valueRequired', true>, K | 'valueRequired'>;
    /**
     * When set, it requires the relationship to always return a value
     */
    required(): ModelRelationalField<SetTypeSubArg<T, 'arrayRequired', true>, K | 'required'>;
    /**
     * When set, it requires the relationship to always return an array value
     * @deprecated this modifier should not be used and will be removed
     * in the next minor version of this package.
     */
    arrayRequired(): ModelRelationalField<SetTypeSubArg<T, 'arrayRequired', true>, K | 'arrayRequired'>;
    /**
     * Configures field-level authorization rules. Pass in an array of authorizations `(a.allow.____)` to mix and match
     * multiple authorization rules for this field.
     */
    authorization<AuthRuleType extends Authorization<any, any, any>>(callback: (allow: AllowModifier) => AuthRuleType | AuthRuleType[]): ModelRelationalField<T, K | 'authorization', K, AuthRuleType>;
};
export type ModelRelationalField<T extends ModelRelationalFieldParamShape, RM extends string | symbol, K extends keyof ModelRelationalField<T, RM> = never, Auth = undefined> = Omit<ModelRelationalFieldFunctions<T, RM, K>, K> & {
    [__auth]?: Auth;
} & Brand<typeof brandName>;
/**
 * Internal representation of Model Field that exposes the `data` property.
 * Used at buildtime.
 */
export type InternalRelationalField = ModelRelationalField<ModelRelationalFieldParamShape, string, never> & {
    data: ModelRelationalFieldData;
};
export type RelationTypeFunctionOmitMapping<Type extends ModelRelationshipTypes> = Type extends ModelRelationshipTypes.belongsTo ? 'required' | 'arrayRequired' | 'valueRequired' : Type extends ModelRelationshipTypes.hasMany ? 'required' : Type extends ModelRelationshipTypes.hasOne ? 'arrayRequired' | 'valueRequired' : never;
export type ModelRelationalTypeArgFactory<RM extends string, RT extends RelationshipTypes, IsArray extends boolean> = {
    type: 'model';
    relatedModel: RM;
    relationshipType: RT;
    array: IsArray;
    valueRequired: false;
    arrayRequired: false;
    references: string[];
};
/**
 * Create a one-directional one-to-one relationship between two models using the `hasOne("MODEL_NAME")` method.
 * A hasOne relationship always uses a reference to the related model's identifier. Typically this is the `id` field
 * unless overwritten with the `identifier()` method.
 * @param relatedModel the name of the related model
 * @returns a one-to-one relationship definition
 */
export declare function hasOne<RM extends string>(relatedModel: RM, references: string | string[]): ModelRelationalField<ModelRelationalTypeArgFactory<RM, ModelRelationshipTypes.hasOne, false>, RM, "valueRequired" | "arrayRequired", undefined>;
/**
 * Create a one-directional one-to-many relationship between two models using the `hasMany()` method.
 * @param relatedModel the name of the related model
 * @returns a one-to-many relationship definition
 */
export declare function hasMany<RM extends string>(relatedModel: RM, references: string | string[]): ModelRelationalField<ModelRelationalTypeArgFactory<RM, ModelRelationshipTypes.hasMany, true>, RM, "required", undefined>;
/**
 * Make a `hasOne()` or `hasMany()` relationship bi-directional using the `belongsTo()` method.
 * The belongsTo() method requires that a hasOne() or hasMany() relationship already exists from
 * parent to the related model.
 * @param relatedModel name of the related `.hasOne()` or `.hasMany()` model
 * @returns a belong-to relationship definition
 */
export declare function belongsTo<RM extends string>(relatedModel: RM, references: string | string[]): ModelRelationalField<ModelRelationalTypeArgFactory<RM, ModelRelationshipTypes.belongsTo, false>, RM, "valueRequired" | "arrayRequired" | "required", undefined>;
export {};
